<!doctype html>
<html lang="zh-tw">

<head>
    <meta charset="utf-8">
    <meta name="revised" content="2026/01/15">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>測試</title>
    <style>
        :root {
            --bg: #0a0f1f;
            --hud-bg: rgba(10, 15, 31, 0.6);
            --hud-border: rgba(0, 255, 255, 0.25);
            --text: #a8ffea;
            --accent: #ff2bd6;
            --accent2: #00f0ff;
            --accent3: #ffe359;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            height: 100%;
            background: radial-gradient(1200px at 20% 10%, #0b1228 0%, #060913 40%, #02040a 100%);
            color: var(--text);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
        }

        #stage {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* Cyberpunk HUD */
        .hud {
            position: fixed;
            left: 24px;
            bottom: 24px;
            padding: 14px 16px;
            border: 1px solid var(--hud-border);
            background: var(--hud-bg);
            backdrop-filter: blur(6px) saturate(140%);
            border-radius: 10px;
            box-shadow: 0 0 0 1px rgba(0, 255, 255, 0.08) inset, 0 0 24px rgba(0, 255, 255, 0.08), 0 0 48px rgba(255, 43, 214, 0.06);
        }

        .title {
            font-weight: 700;
            letter-spacing: 0.08em;
            font-size: 12px;
            color: var(--accent2);
            text-shadow: 0 0 8px rgba(0, 240, 255, 0.6);
            margin-bottom: 8px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(2, minmax(180px, 1fr));
            gap: 8px 16px;
        }

        label {
            display: grid;
            grid-template-columns: 90px 1fr;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: #b9f7ff;
        }

        input[type="range"] {
            appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 6px;
            background: linear-gradient(90deg, rgba(0, 240, 255, 0.2), rgba(255, 43, 214, 0.2));
            outline: none;
            box-shadow: 0 0 12px rgba(0, 240, 255, 0.25) inset;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #fff 0%, #a8ffea 30%, #00f0ff 60%, #ff2bd6 100%);
            box-shadow: 0 0 12px rgba(255, 43, 214, 0.8), 0 0 24px rgba(0, 240, 255, 0.6);
        }

        .hint {
            margin-top: 8px;
            font-size: 11px;
            color: #8bd9ff;
            opacity: 0.9;
        }
    </style>
    
</head>

<body> <canvas id="stage"></canvas> <!-- UI -->
    <div class="hud">
        <div class="title">CYBERPUNK PARTICLES — TEST</div>
        <div class="controls">
            <label>
                <span>Attraction</span>
                <input type="range" id="attract" min="0" max="1" step="0.01" value="0.35" />
            </label>
            <label>
                <span>Repulsion</span>
                <input type="range" id="repulse" min="0" max="1" step="0.01" value="0.75" />
            </label>
            <label>
                <span>Fluid wave</span>
                <input type="range" id="fluid" min="0" max="1" step="0.01" value="0.6" />
            </label>
            <label>
                <span>Glow</span>
                <input type="range" id="glow" min="0" max="1" step="0.01" value="0.8" />
            </label>
        </div>
        <div class="hint">Move your mouse—particles will push, pull, and ripple.</div>
    </div>
    <script>
        /* Cyberpunk Particle Effect — TEST
   6,000 independent particles forming "test" with repulsion, attraction, and fluid waves.
*/

        (() => {
            const canvas = document.getElementById('stage');
            const ctx = canvas.getContext('2d', { alpha: false });

            // UI controls
            const ui = {
                attract: document.getElementById('attract'),
                repulse: document.getElementById('repulse'),
                fluid: document.getElementById('fluid'),
                glow: document.getElementById('glow'),
            };

            // DPR & resize
            let W = 0, H = 0, DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
            const resize = () => {
                W = canvas.clientWidth = window.innerWidth;
                H = canvas.clientHeight = window.innerHeight;
                canvas.width = Math.floor(W * DPR);
                canvas.height = Math.floor(H * DPR);
                ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                // Rebuild target map on resize
                buildTarget();
            };
            window.addEventListener('resize', resize, { passive: true });

            // Mouse state
            const mouse = {
                x: 0, y: 0,
                vx: 0, vy: 0,
                px: 0, py: 0,
                down: false,
                movedAt: performance.now()
            };
            const onMove = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
                const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
                const now = performance.now();
                mouse.vx = (x - mouse.x) / Math.max(1, (now - mouse.movedAt));
                mouse.vy = (y - mouse.y) / Math.max(1, (now - mouse.movedAt));
                mouse.x = x; mouse.y = y; mouse.movedAt = now;
            };
            canvas.addEventListener('mousemove', onMove, { passive: true });
            canvas.addEventListener('touchmove', onMove, { passive: true });
            canvas.addEventListener('mousedown', () => mouse.down = true);
            canvas.addEventListener('mouseup', () => mouse.down = false);
            canvas.addEventListener('touchstart', () => mouse.down = true);
            canvas.addEventListener('touchend', () => mouse.down = false);

            // Particle system
            const COUNT = 1000;
            const particles = new Array(COUNT);
            const targetPoints = new Array(COUNT);

            // Offscreen text rasterization to sample target points
            const textCanvas = document.createElement('canvas');
            const tctx = textCanvas.getContext('2d');

            function buildTarget() {
                // Render "test" to offscreen and sample points
                const scale = Math.min(W * 0.8, H * 0.5);
                const fontSize = Math.max(64, Math.floor(scale));
                const padding = 40;

                textCanvas.width = Math.floor(W);
                textCanvas.height = Math.floor(H);

                tctx.setTransform(1, 0, 0, 1, 0, 0);
                tctx.clearRect(0, 0, textCanvas.width, textCanvas.height);
                tctx.fillStyle = '#fff';
                tctx.textAlign = 'center';
                tctx.textBaseline = 'middle';
                tctx.font = `bold ${fontSize}px "Segoe UI", Roboto, Arial, sans-serif`;

                const text = 'Wong';
                tctx.fillText(text, textCanvas.width / 2, textCanvas.height / 2);

                // Sample points from alpha mask
                const img = tctx.getImageData(0, 0, textCanvas.width, textCanvas.height);
                const data = img.data;
                const pts = [];
                const step = Math.max(2, Math.floor(fontSize / 40)); // sampling stride

                for (let y = 0; y < img.height; y += step) {
                    for (let x = 0; x < img.width; x += step) {
                        const idx = (y * img.width + x) * 4 + 3; // alpha channel
                        if (data[idx] > 32) {
                            pts.push({ x, y });
                        }
                    }
                }

                // Evenly map to COUNT particles
                const needed = COUNT;
                const sampled = [];
                if (pts.length === 0) {
                    // Fallback grid
                    const cols = Math.floor(Math.sqrt(needed));
                    const rows = Math.ceil(needed / cols);
                    const gx = (W - cols * step) / 2;
                    const gy = (H - rows * step) / 2;
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            if (sampled.length >= needed) break;
                            sampled.push({ x: gx + c * step, y: gy + r * step });
                        }
                    }
                } else {
                    const ratio = pts.length / needed;
                    for (let i = 0; i < needed; i++) {
                        sampled.push(pts[Math.floor(i * ratio) % pts.length]);
                    }
                }

                // Assign target points
                for (let i = 0; i < COUNT; i++) {
                    targetPoints[i] = {
                        x: sampled[i].x,
                        y: sampled[i].y
                    };
                    if (!particles[i]) {
                        // Initialize particles near center with random spread
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 20 + Math.random() * 60;
                        particles[i] = {
                            x: W / 2 + Math.cos(angle) * radius,
                            y: H / 2 + Math.sin(angle) * radius,
                            vx: 0, vy: 0,
                            // neon palette index
                            hue: (Math.random() * 360) | 0,
                            life: Math.random() * 1.0,
                            mass: 1.0,
                        };
                    }
                }
            }

            // Cyberpunk colorizer
            function neonColor(i, glowStrength) {
                // Cluster hues around cyan/magenta/yellow with jitter
                const base = [190, 300, 55][i % 3];
                const jitter = (i * 13.37) % 40 - 20;
                const h = (base + jitter + (Math.sin(i * 0.001) * 30)) % 360;
                const s = 100;
                const l = 60;
                const alpha = 0.85;
                const glow = Math.max(0, Math.min(1, glowStrength));
                ctx.shadowColor = `hsla(${h}, ${s}%, ${l}%, ${0.35 + glow * 0.45})`;
                ctx.shadowBlur = 12 + glow * 24;
                return `hsla(${h}, ${s}%, ${l}%, ${alpha})`;
            }

            // Simple pseudo-noise for fluid waves
            function noise2D(x, y, t) {
                // Hash-based value noise
                const s = Math.sin(x * 0.013 + y * 0.017 + t * 0.0023) * 43758.5453;
                return s - Math.floor(s);
            }

            // Simulation parameters
            const params = {
                damping: 0.92,
                maxSpeed: 3.5,
                targetSpring: 0.08, // base attraction to target
                mouseRadius: 140,
                mouseRepulse: parseFloat(ui.repulse.value),
                mouseAttract: parseFloat(ui.attract.value),
                fluidStrength: parseFloat(ui.fluid.value),
                glow: parseFloat(ui.glow.value),
            };

            // Bind UI
            ui.attract.addEventListener('input', () => params.mouseAttract = parseFloat(ui.attract.value));
            ui.repulse.addEventListener('input', () => params.mouseRepulse = parseFloat(ui.repulse.value));
            ui.fluid.addEventListener('input', () => params.fluidStrength = parseFloat(ui.fluid.value));
            ui.glow.addEventListener('input', () => params.glow = parseFloat(ui.glow.value));

            // Main loop
            let last = performance.now();
            function step(now) {
                const dt = Math.min(32, now - last);
                last = now;

                // Clear with subtle vignette
                ctx.fillStyle = '#060913';
                ctx.fillRect(0, 0, W, H);

                // Fluid time
                const t = now;

                // Draw & update
                const mr = params.mouseRadius;
                const mx = mouse.x, my = mouse.y;

                for (let i = 0; i < COUNT; i++) {
                    const p = particles[i];
                    const target = targetPoints[i];

                    // Attraction to target (spring)
                    const dxT = target.x - p.x;
                    const dyT = target.y - p.y;
                    const distT = Math.hypot(dxT, dyT) + 1e-6;
                    const spring = params.targetSpring;
                    p.vx += (dxT / distT) * spring;
                    p.vy += (dyT / distT) * spring;

                    // Mouse forces: repulsion & attraction blend
                    const dxM = p.x - mx;
                    const dyM = p.y - my;
                    const distM = Math.hypot(dxM, dyM) + 1e-6;
                    if (distM < mr) {
                        const normX = dxM / distM;
                        const normY = dyM / distM;
                        const proximity = 1 - (distM / mr);

                        // Repulsion scales with proximity
                        const repulse = params.mouseRepulse * proximity * 1.6;
                        p.vx += normX * repulse;
                        p.vy += normY * repulse;

                        // Attraction (counter-force) modulated by mouse velocity—feels fluid
                        const attract = params.mouseAttract * proximity * (0.6 + Math.min(1.8, Math.hypot(mouse.vx, mouse.vy) * 0.02));
                        p.vx -= normX * attract;
                        p.vy -= normY * attract;

                        // Tangential swirl—fluid-like wave
                        const tangential = params.fluidStrength * proximity * 1.2;
                        // Perpendicular to mouse vector
                        const tx = -normY;
                        const ty = normX;
                        p.vx += tx * tangential;
                        p.vy += ty * tangential;
                    }

                    // Background fluid noise field
                    const n = noise2D(p.x * 0.9, p.y * 0.9, t);
                    const angle = (n * Math.PI * 2);
                    const flow = params.fluidStrength * 0.35;
                    p.vx += Math.cos(angle) * flow * 0.2;
                    p.vy += Math.sin(angle) * flow * 0.2;

                    // Damping & speed clamp
                    p.vx *= params.damping;
                    p.vy *= params.damping;
                    const spd = Math.hypot(p.vx, p.vy);
                    if (spd > params.maxSpeed) {
                        const s = params.maxSpeed / spd;
                        p.vx *= s; p.vy *= s;
                    }

                    // Integrate
                    p.x += p.vx;
                    p.y += p.vy;

                    // Soft bounds
                    if (p.x < -50 || p.x > W + 50 || p.y < -50 || p.y > H + 50) {
                        p.x = W / 2 + (Math.random() - 0.5) * 40;
                        p.y = H / 2 + (Math.random() - 0.5) * 40;
                        p.vx = p.vy = 0;
                    }

                    // Render
                    ctx.fillStyle = neonColor(i, params.glow);
                    // Particle size subtly varies with speed for extra energy
                    const r = 1.0 + Math.min(1.5, spd * 0.25);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                    ctx.fill();
                }

                requestAnimationFrame(step);
            }

            // Boot
            resize();
            requestAnimationFrame(step);
        })();
    </script>
</body>

</html>

</html>